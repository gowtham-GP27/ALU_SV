`timescale 1ns/1ns
`define width 8
`define n 4
`define transactions 10
`include "ALU_DESIGN.sv"

//------------------- Interface --------------------------

interface intf();
  logic [`width-1:0] opa, opb;
  logic [`n-1:0] cmd;
  logic [1:0] inp_valid;
  logic ce, cin;
  logic reset;
  logic g, e, l, err, cout, oflow;
  logic [`width:0] res;
  logic mode;
  logic clk;

  clocking drv_cb@(posedge clk);
    default input #0 output #0;
    output opa, opb, cmd, inp_valid, mode, ce, cin;
    input reset;
  endclocking

  clocking mon_cb@(posedge clk);
    default input #0 output #0;
    input res, cmd, err, g, e, l, cout, reset, oflow;
    input opa, opb, inp_valid, mode, ce, cin;
  endclocking

  clocking ref_cb@(posedge clk);
    default input #0 output #0;
    input opa, opb, cmd, inp_valid, mode, ce, cin, reset;
  endclocking

  modport DRV(clocking drv_cb);
  modport MON(clocking mon_cb);
  modport REF(clocking ref_cb);
  modport DUT(
    input opa, input opb, input cmd, input inp_valid, input mode, input ce, inpu                                                                                                             t cin,
    output res, output err, output oflow, output cout, output g, output e, outpu                                                                                                             t l
  );
endinterface

//------------------- Transaction Class --------------------------

class transaction#(parameter width=`width, n=`n);
  rand bit [width-1:0] opa, opb;
  rand bit [n-1:0] cmd;
  rand bit mode, cin, ce;
  rand bit [1:0] inp_valid;
  bit [width:0] res;
  bit reset;
  bit g, e, l, cout, err, oflow, clk;

  constraint d1 { mode dist {1 := 5, 0 := 5}; }
  constraint d2 { ce dist {1 := 95, 0 := 5}; }
  constraint d3 { inp_valid dist { [1:3] := 90, 0 := 10}; }
  constraint fix_reset { reset == 0; } // Force reset to 0 for normal operation

  function transaction copy();
    copy = new();
    copy.opa = opa;
    copy.opb = opb;
    copy.cmd = cmd;
    copy.reset = reset;
    copy.mode = mode;
    copy.cin = cin;
    copy.inp_valid = inp_valid;
    copy.res = res;
    copy.g = g;
    copy.e = e;
    copy.l = l;
    copy.cout = cout;
    copy.err = err;
    copy.oflow = oflow;
    return copy;
  endfunction
endclass

//------------------- Generator --------------------------

class generator;
  transaction#(`width, `n) trans_m;
  mailbox #(transaction#(`width, `n)) mbx_d;
  event done;

  function new(mailbox #(transaction#(`width, `n)) mbx_d);
    this.mbx_d = mbx_d;
  endfunction

  task run();
    for (int i = 0; i < `transactions; i++) begin
      trans_m = new();
      trans_m.reset = 0; // Explicitly force reset off
      if (trans_m.randomize()) begin
        mbx_d.put(trans_m.copy());
        $display("[%0t][GEN] Sent transaction: opa=%d, opb=%d, cmd=%d, inp_valid                                                                                                             =%b, ce=%d, mode=%d, reset=%b",
                 $time, trans_m.opa, trans_m.opb, trans_m.cmd, trans_m.inp_valid                                                                                                             , trans_m.ce, trans_m.mode, trans_m.reset);
      end else
        $display("[%0t][GEN] Randomize failed", $time);
      #10;
    end
    $display("[%0t][GEN] completed", $time);
    ->done;
  endtask
endclass

//------------------- Driver --------------------------

class driver;
  transaction#(`width, `n) data;
  mailbox #(transaction#(`width, `n)) mbx_d, mbx_r;
  virtual intf.DRV aif;

  function new(mailbox #(transaction#(`width, `n)) mbx_d, mailbox #(transaction#                                                                                                             (`width, `n)) mbx_r, virtual intf.DRV aif);
    this.mbx_d = mbx_d;
    this.mbx_r = mbx_r;
    this.aif = aif;
  endfunction

  task run();
    repeat (3) @(aif.drv_cb);
    $display("[%0t][DRV] started", $time);
    for (int i = 0; i < `transactions; i++) begin
      mbx_d.get(data);

      aif.drv_cb.opa       <= data.opa;
      aif.drv_cb.opb       <= data.opb;
      aif.drv_cb.cmd       <= data.cmd;
      aif.drv_cb.inp_valid <= data.inp_valid;
      aif.drv_cb.mode      <= data.mode;
      aif.drv_cb.cin       <= data.cin;
      aif.drv_cb.ce        <= data.ce;

      repeat (2) @(aif.drv_cb);

      mbx_r.put(data.copy());
      $display("[%0t][DRV] Sent to REF: opa=%d, opb=%d, cmd=%d, inp_valid=%b, ce                                                                                                             =%d, mode=%d",
               $time, data.opa, data.opb, data.cmd, data.inp_valid, data.ce, dat                                                                                                             a.mode);
    end
  endtask
endclass

//------------------- Monitor --------------------------

class monitor;
  transaction#(`width, `n) trans_m;
  mailbox #(transaction#(`width, `n)) mbx_m;
  virtual intf.MON aif;

  function new(mailbox #(transaction#(`width, `n)) mbx_m, virtual intf.MON aif);
    this.mbx_m = mbx_m;
    this.aif = aif;
  endfunction

  task run();
    repeat (4) @(aif.mon_cb);
    for (int i = 0; i < `transactions; i++) begin
      trans_m = new();
      repeat (1) @(aif.mon_cb);

      trans_m.opa       = aif.mon_cb.opa;
      trans_m.opb       = aif.mon_cb.opb;
      trans_m.cmd       = aif.mon_cb.cmd;
      trans_m.inp_valid = aif.mon_cb.inp_valid;
      trans_m.mode      = aif.mon_cb.mode;
      trans_m.cin       = aif.mon_cb.cin;
      trans_m.ce        = aif.mon_cb.ce;
      trans_m.reset     = aif.mon_cb.reset;
      trans_m.res       = aif.mon_cb.res;
      trans_m.err       = aif.mon_cb.err;
      trans_m.cout      = aif.mon_cb.cout;
      trans_m.oflow     = aif.mon_cb.oflow;
      trans_m.g         = aif.mon_cb.g;
      trans_m.e         = aif.mon_cb.e;
      trans_m.l         = aif.mon_cb.l;

      $display("[%0t][MON] Sampled DUT outputs: res=%d, err=%b, cout=%b, oflow=%                                                                                                             b, g=%b, e=%b, l=%b",
               $time, trans_m.res, trans_m.err, trans_m.cout, trans_m.oflow, tra                                                                                                             ns_m.g, trans_m.e, trans_m.l);

      mbx_m.put(trans_m.copy());
    end
  endtask
endclass

//------------------- Reference --------------------------

class reference;
  transaction#(`width, `n) trans_r;
  mailbox #(transaction#(`width, `n)) mbx_r, mbx_s;
  virtual intf.REF aif;

  function new(mailbox #(transaction#(`width, `n)) mbx_r, mailbox #(transaction#                                                                                                             (`width, `n)) mbx_s, virtual intf.REF aif);
    this.mbx_r = mbx_r;
    this.mbx_s = mbx_s;
    this.aif = aif;
  endfunction

  task run();
    for (int i = 0; i < `transactions; i++) begin
      mbx_r.get(trans_r);
      $display("[%0t][REF] Received transaction: reset=%b, ce=%b, opa=%d, opb=%d                                                                                                             , cmd=%d, inp_valid=%b",
               $time, trans_r.reset, trans_r.ce, trans_r.opa, trans_r.opb, trans                                                                                                             _r.cmd, trans_r.inp_valid);

      if (trans_r.reset == 1 || trans_r.ce == 0) begin
        trans_r.res = 0;
        trans_r.g = 0; trans_r.e = 0; trans_r.l = 0;
        trans_r.oflow = 0; trans_r.cout = 0; trans_r.err = 0;
      end else begin
        // Sample command handling, example for mode==1 cmd==0
        if (trans_r.mode == 1 && trans_r.cmd == 0 && trans_r.inp_valid == 2'b11)                                                                                                              begin
          trans_r.res = trans_r.opa + trans_r.opb;
          trans_r.cout = trans_r.res[`width];
          trans_r.err = 0;
        end else begin
          trans_r.err = 1;
          trans_r.res = 0;
        end
        // Extend logic to cover all cmd, mode cases according to ALU spec
      end

      mbx_s.put(trans_r.copy());
      $display("[%0t][REF] Computed expected: res=%d, err=%b, cout=%b", $time, t                                                                                                             rans_r.res, trans_r.err, trans_r.cout);
    end
  endtask
endclass

//------------------- Scoreboard --------------------------

class scoreboard;
  mailbox #(transaction#(`width, `n)) mbx_s, mbx_m;
  transaction#(`width, `n) trans_r, trans_m;

  function new(mailbox #(transaction#(`width, `n)) mbx_s, mailbox #(transaction#                                                                                                             (`width, `n)) mbx_m);
    this.mbx_s = mbx_s;
    this.mbx_m = mbx_m;
  endfunction

  task run();
    for (int i = 0; i < `transactions; i++) begin
      mbx_s.get(trans_r);
      mbx_m.get(trans_m);

      $display("[%0t][SCB] REF res=%d err=%d cout=%b g=%b e=%b l=%b | MON res=%d                                                                                                              err=%d cout=%b g=%b e=%b l=%b",
               $time,
               trans_r.res, trans_r.err, trans_r.cout, trans_r.g, trans_r.e, tra                                                                                                             ns_r.l,
               trans_m.res, trans_m.err, trans_m.cout, trans_m.g, trans_m.e, tra                                                                                                             ns_m.l);

      if (trans_r.res === trans_m.res)
        $display("[%0t][SCB] RESULT PASS", $time);
      else
        $display("[%0t][SCB] RESULT FAIL", $time);

      if (trans_r.err === trans_m.err)
        $display("[%0t][SCB] ERR PASS", $time);
      else
        $display("[%0t][SCB] ERR FAIL", $time);

      if (trans_r.cout === trans_m.cout)
        $display("[%0t][SCB] COUT PASS", $time);
      else
        $display("[%0t][SCB] COUT FAIL", $time);

      if (trans_r.g === trans_m.g)
        $display("[%0t][SCB] G PASS", $time);
      else
        $display("[%0t][SCB] G FAIL", $time);

      if (trans_r.e === trans_m.e)
        $display("[%0t][SCB] E PASS", $time);
      else
        $display("[%0t][SCB] E FAIL", $time);

      if (trans_r.l === trans_m.l)
        $display("[%0t][SCB] L PASS", $time);
      else
        $display("[%0t][SCB] L FAIL", $time);

      $display("-------------------------");
    end
  endtask
endclass

//------------------- Environment --------------------------

class environment;
  virtual intf dif, mif, rif;
  mailbox #(transaction#(`width, `n)) mbx_d, mbx_r, mbx_s, mbx_m;
  generator gen;
  driver drv;
  monitor mon;
  reference ref1;
  scoreboard scb;

  function new(virtual intf dif, virtual intf mif, virtual intf rif);
    this.dif = dif;
    this.mif = mif;
    this.rif = rif;
  endfunction

  task build();
    $display("[%0t][ENV] Build started", $time);
    mbx_d = new();
    mbx_r = new();
    mbx_s = new();
    mbx_m = new();

    gen = new(mbx_d);
    drv = new(mbx_d, mbx_r, dif);
    ref1 = new(mbx_r, mbx_s, rif);
    mon = new(mbx_m, mif);
    scb = new(mbx_s, mbx_m);
    $display("[%0t][ENV] Build complete", $time);
  endtask

  task run();
    $display("[%0t][ENV] Run started", $time);
    fork
      gen.run();
      drv.run();
      mon.run();
      ref1.run();
      scb.run();
    join
    $display("[%0t][ENV] Run complete", $time);
  endtask
endclass

//------------------- Test --------------------------

class test;
  virtual intf dif, rif, mif;
  environment env;

  function new(virtual intf dif, virtual intf mif, virtual intf rif);
    this.dif = dif;
    this.mif = mif;
    this.rif = rif;
  endfunction

  task run();
    $display("[%0t][TEST] START", $time);
    env = new(dif, mif, rif);
    env.build();
    env.run();
    $display("[%0t][TEST] COMPLETE", $time);
  endtask
endclass

//------------------- Top module --------------------------

module top();
  intf aif();

  initial begin
    aif.clk = 0;
    forever #5 aif.clk = ~aif.clk;
  end

  initial begin
    aif.reset = 1;
    @(posedge aif.clk);
    aif.reset = 0;
  end

  ALU_DESIGN dut(
    .OPA(aif.opa),
    .OPB(aif.opb),
    .CLK(aif.clk),
    .RST(aif.reset),
    .CE(aif.ce),
    .MODE(aif.mode),
    .CIN(aif.cin),
    .CMD(aif.cmd),
    .INP_VALID(aif.inp_valid),
    .RES(aif.res),
    .COUT(aif.cout),
    .OFLOW(aif.oflow),
    .G(aif.g),
    .L(aif.l),
    .E(aif.e),
    .ERR(aif.err)
  );

  test test_1 = new(aif.DRV, aif.MON, aif.REF);

  initial begin
    $display("[%0t] SIMULATION START", $time);
    test_1.run();
    $display("[%0t] SIMULATION END", $time);
    $finish;
  end
endmodule
